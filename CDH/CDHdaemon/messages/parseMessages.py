#!/bin/python3

import json

jsonFile="messages.json"
PyFile="messages.py"
CFile="messages.h"

print("--- MESSAGES PARSER ---")

print("Reading {0}".format(jsonFile))
#opening messages file
msgfile=open("messages.json","r")

#loading json into dictionary
y=json.load(msgfile)

#extracting C types dictionary
CTypesDict=y["C types"]

#extracting Py types dictionary
PyTypesDict=y["Py types"]

#extracting messages dictionary
messages=y["messages"]

print("Creating {0} and {1}".format(PyFile,CFile))

#opening C header file
cheader=open("messages.h","w")
#opening python structure classes file
pyheader=open("messages.py","w")

print("Writing files")

#header/module headers
cheader.write("#ifndef MESSAGES_H\n#define MESSAGES_H\n")
cheader.write("\n/*\n Automatically generated by parseMessages.py\n from messages.json\n*/\n\n")
cheader.write("#include <stdint.h>\n\n")
pyheader.write("# Automatically generated by parseMessages.py\n# from messages.json\n\n")
pyheader.write("from ctypes import *\n")
pyheader.write("import shlex\n\n")

#printing messages structs/classes
for msg in messages.keys():

	#string used for __str__ function definition
	strstring=""
	
	#string used for type conversion list building
	typeListStr=""

	cheader.write("// message name: {0} code: {1}\n".format(msg,messages[msg]["code"]))
	cheader.write("#define {0}_CODE {1}\n".format(msg.upper(),messages[msg]["code"]))
	pyheader.write("# message name: {0} code: {1}\n".format(msg,messages[msg]["code"]))
	cheader.write("typedef struct {\n")
	pyheader.write("class {0}(Structure):\n".format(msg))
	pyheader.write("\tdef __init__(self):\n\t\tsuper().__init__()\n\t\tself.code={0}\n\n".format(messages[msg]["code"]))
	pyheader.write("\t_pack_=1\n")
	pyheader.write("\t_fields_=[")
	currtype=""
	try:
		currType=CTypesDict["c_uint8"]
	except:
		print("ERROR! c_uint8 type not defined for code of {0}".format(msg))
		
	cheader.write("\t{0} code;\n".format(currType))
	pyheader.write('("code",c_uint8)'.format(currType))
		
	typeListStr+="int,"
	
	if "fields" in messages[msg]:
		for field in messages[msg]["fields"].keys():
			typeStr=messages[msg]["fields"][field]
			elemNum=1
			typeStrSplit=typeStr.split("*",1)
			if len(typeStrSplit) != 1:
				elemNum=typeStrSplit[1]
				
			try:
				currType=CTypesDict[typeStrSplit[0]]
				elemNum=int(elemNum)
				if elemNum<=0:
					raise Exception("Negative erray elements number")
			except:
				print("ERROR!, {0}->{1}->{2} is not a valid type".format(msg,field,typeStr))
			else:
				cheader.write("\t{0} {1}".format(currType,field))
				if elemNum!=1:
					cheader.write("[{0}];\n".format(elemNum))
				else:
					cheader.write(";\n".format(elemNum))
				pyheader.write(',\n\t\t("{0}",{1})'.format(field,typeStr))
				strstring+=" <{0} {1}>".format(typeStr,field)
				typeListStr+="{0},".format(PyTypesDict[typeStrSplit[0]])
				
		cheader.write("}}__attribute__((packed)) {0};\n\n".format(msg))
		pyheader.write(']\n\n'.format(field,currType))
	
	#defining __str__ function for each class
	pyheader.write('\tdef __str__(self):\n'.format(field,currType))
	pyheader.write('\t\treturn "{0}{1}"\n\n'.format(msg,strstring))

	#defining type conversion list for fields
	typeListStr=typeListStr.rstrip(",")
	pyheader.write("\tconvList=[{0}]\n\n".format(typeListStr))

cheader.write("#endif")

#printing classes dictionary (code : messageClass)
pyheader.write("# messages dictionary (keys are the codes)\n")
pyheader.write("# can be used to instantiate class from msg code\n")
pyheader.write("msgDict={\n")
for msg in messages.keys():
	pyheader.write('{0}:{1}'.format(messages[msg]["code"],msg))
	if msg!=list(messages.keys())[-1]:
		pyheader.write(",\n")
	else:
		pyheader.write("\n}")

#printing python string parsing function
pyheader.write("\n\n# String parsing function, this can be used to fill and return a\n")
pyheader.write("# structure class from a string, this string should\n")
pyheader.write("# contain each structure element value separated by spaces\n")
pyheader.write('# array elements should be passed in quotes "el1, el2, el3, ..."\n')
pyheader.write("# the string should start with the structure name as first element\n")
pyheader.write("# and the function will return the corresponding filled structure in\n")
pyheader.write("# case of success or throw an exception in case of failure")
pyheader.write('''
def parseStruct(str):

	args=shlex.split(str)
	if len(args)==0:
		raise Exception
	else:
		for msg in msgDict.keys():
			if msgDict[msg].__name__==args[0]:
				retStruct=msgDict[msg]()
				numFields=len(retStruct._fields_)
				if numFields!=len(args):
					raise Exception
				f=1
				for field in retStruct._fields_[1:]:
					#check if element is array
					if isinstance(getattr(retStruct,field[0]), Array):
						arrayElem=args[f].split(",")
						#converting string to type
						arrayType=retStruct.convList[f]
						convVals=[arrayType(_) for _ in arrayElem]
						#copying elements into field
						setattr(retStruct,field[0],type(getattr(retStruct,field[0]))(*convVals))
					else: #if single number
						#converting string to type
						convVal=retStruct.convList[f](args[f])
						setattr(retStruct,field[0],convVal)
						
					f+=1
		
				return retStruct
		
		raise Exception
''')

pyheader.close()
cheader.close()

print("Done.")
